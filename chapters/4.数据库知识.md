# 4 数据库知识
## 4.1 DDL
### 4.1.1 mysql中char与varchar 有什么区别？
都可用于存取字符串，但其保持和检索方法不同。
1. char是固定长度数据类型，未存满则用空在右侧填充，varchar是可变长度数据类型
2. char的长度固定，所以其存入效率较高， 但缺点是占用空间较大，varchar可变，所以存多少占多少空间， 但是在变长过程中需要消耗资源；
3. MyISAM建议使用固定长度代替可变长；
4. InnoDB由于内部没有区分固长和可变长，存储都是使用指针，所以VARCHAR效率好于CHAR

### 4.1.2 VARCHAR(50)中的50和INT(20)中的20分别代表什么？
VARCHAR(50)中的50表示最多存放50个字符， 如果只有10个字符，VARCHAR(50)和VARCHAR(200)所占用的控件是一样的， 知识VARCHAR(200)会消耗更多的内存，因为排序时采用
fixed_length计算长度
INT(20)中的20表示显示20个字符的宽度，INT(1) INT(20)存储其实都一样，都是4个字节

## 4.2 DML

## 4.3 设计方法

## 4.4 理论
### 4.4.1 mysql中 MyisAM和InnoDB有什么区别？
1. innodb支持事务，而myisam不支持，所以mysql现在的默认数据库都是myisam
2. innodb支持外键，myisam不支持
3. innodb不保存表的具体行数，count全表扫描，myisam使用独立的变量保存函数
4. myisam支持全文索引，但不支持中文， mysql5.7以前不支持全文， 5.7后支持且支持中文
5. Inodb是聚簇索引，而myisam是非聚簇索引，聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

这是一个老生常谈的面试题，就现在而言多数都是选择innodb

### 4.4.2 Mysql Innodb为什么建议用自增列作为主键？
1.InnoDB使用聚集索引，聚集索引根的选择顺序为 ①主键 ②不为null的唯一索引 ③6字节RWID
2.数据本身存于主索引（一颗B+Tree）的叶子节点上， 这要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据按主键顺序存放。
因此每当一条新记录插入，MYsql会根据其主键插入适当的节点和位置，如果页面达到装在因子（innodb默认为15/16），则开辟一个新的页（节点）
3.如果使用自增主键，每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页
4.如果使用非自增主键，由于每次插入主键的值近似于随机。因此每次新记录都要被插到现有索引页的中间某个位置。
此时mysql不得不为了将新记录查到合适位置而移动数据，甚至目标页面可能已经被会写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这就增加了很多的开销。
同时频繁的移动，分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来冲减表并优化填充页面

### 4.4.3 为什么使用索引能提高效率？
1.索引是有序的
2.在有序的情况下，通过索引查询一个数据是无须遍历索引记录的
3.极端情况下，索引查询效率为二分法查询效率，趋近于log2(N)

### 4.4.4 B+树索引和哈希索引有什么区别？
1.B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互连接，是有序的
2.哈希索引就是采用一定哈希算法，把键值换成哈希值，检索时不需要像B+树那样从根节点到叶子节点查到，只需要一次哈希计算即可，是无须的

### 4.4.5 哈希索引有什么优势？
等值查询，且没有大量的重复的值时，如果有大量重复值会产生哈希碰撞问题，效率很低

### 4.4.6 哈希索引不适用于哪些场景？
1.不支持范围查询
2.不支持索引完成排序
3.不支持联合索引的最左前缀匹配规则
通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：

在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种SQL：

仅等值查询

select id, name from table where name='李明'; 

而常用的 InnoDB 引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。

如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。

通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。

注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。

但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。

### 4.4.7 B树和B+树有什么区别？
1.B树每个节点都存储KEY与DATA，所有节点组成这棵树，并且叶子节点指针为nul, 叶子节点不包含任何关键字信息
2.所有叶子节点中包含全部关键字信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)

### 4.4.8 mysql为什么使用B+树作为存储结构？
B+树有以下优点：
1. B+树层级更少
相较于B树B+的每个叶子节点存储的关键字数更多，树的层级更少所以查询数据更快？

2.B+树查询速度更稳定
B+树所有关联字数据地址都存储在叶子节点上，所以每次查找的次数都相同，所以查询速度更稳定

3.B+树天然具备排序功能
B+树所有叶子节点数据构成一个有序链表，在查询大小区间的数据时更方便，数据紧密性很高，缓存的命中率也会比B树高

4.B+树全节点遍历更快
B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样对每一层进行遍历，这有利于数据库做全表扫描

### 4.4.9 你对mysql的联合索引有什么样的认知？
1.联合索引是两个或多个列上的索引
对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。
例如索引是key index (a,b,c). 可以支持a 、 a,b 、 a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。

2.利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。
复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。
如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不知道姓，电话簿将没有用处

### 4.4.10 设么情况下应该不建或者少建索引？
1.表记录太少
2.经常插入、删除、修改的表
3.数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。
4.经常和主字段一块查询但主字段索引值比较多的表字段

### 4.4.11 什么是表分区？
指按照一定规则，将数据库中的表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但底层确实由多个物理分区组成。

### 4.4.12 分区与分表有什么区别？
分表是指通过一定规则，将一张表分为多张不同的表，而分区表从逻辑上上讲还是同一张表，只是物理存储分开

### 4.4.13 表分区有什么好处？
1.存储更多数据
分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备，和单个磁盘或文件系统相比，可以存储更多数据

2.优化查询
在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率，涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。

3.分区表更容易维护，例如像大批删除数据时可以清除整个分区

4.避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等

### 4.4.14 分区表有哪些限制因素？
1.一个表最后只能由1024个分区
2.如果分区字段有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来，即分区字段要么不包含主键字段和唯一字段，要么包含所有主键字段和唯一字段
3.分区表中无法使用外键约束
4.Mysql的分区适用于一个表的所有数据和索引，不能只对数据表分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。

### 4.4.15 如何判断当前Mysql是否支持分区？
```php
show variables like '%partition%' 
```

### 4.4.16 Mysql支持的分区类型有哪些？
1.RANGE分区
这种模式允许将数据划分不同范围，例如可以将表通过年份划分多个分区

2.LIST分区
这种模式允许系统通过预定义的列表的值来对数据进行分割，按照LIST中的值分区，与RANGE分区的区别是，RANGE分区的区间范围是连续的

3.HASH分区
这种模式允许通过对表的一个或多个列的HASH KEY进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。

4.KEY分区
上面HASH模式的一种延伸，这里的HASH事由MYSQL 系统产生的

### 4.4.17 谈谈你对MVCC协议的认识？
MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) 
注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control

MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。
LBCC：Lock-Based Concurrency Control，基于锁的并发控制
MVCC：Multi-Version Concurrency Control

基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。

在MVCC并发控制中，读操作可以分成两类：
快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）
当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录

### 4.4.18 行级所有哪些优缺点？
优点：
1.当在许多线程中访问不同的行时只存在少量锁定冲突。
2.回滚时只有少量的更改
3.可以长时间锁定单一的行。

缺点：
1.比页级锁或表级锁占用更多的内存
2.当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁
3.如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多
4.用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。

### 4.4.19 Mysql复制能解决哪些问题？
1.高可用和故障切换,复制能够避免Mysql单点故障，也可以在Master失效后将slave升级为matser.
2.负载均衡
3.数据备份
4.业务模块化

### 4.4.20 Mysql复制原理及流程？
复制的流程：
1.Master将数据改变记录到Binary Log, 也就是配置文件Log-Bin指定的配置文件，这些记录叫做二进制日志事件(Binary Log Events)
2.Slave通过I/O读取Master中的Binary Log Events并写入到它的中继日志（relay log）
3.Slave重做中继日志中事件，把中继日志中的事件信息一条一条地在本地执行一次，完成数据在本地的存储，从而实现将改变反映到它自己的数据(数据重放)

复制涉及到三个线程：
主节点 binary log dump 线程（IO线程）
当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。

从节点I/O线程
当从节点上执行start slave命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。

从节点SQL线程
SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。

### 4.4.21 说说你对Mysql日志的认识？
1. 重做日志（Redo Log)
**作用** 确保事务的持久性，redo记录事务执行后转台，用来恢复未写入data file的已成功事务更新的数据，防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务持久性这一也行。
**内容** 物理格式的日志，记录是物理数据页面的修改的信息，其redo log是书序写入redo log file的无路文件中去的
**什么时候产生** 事务开始之后就产生redo log, redo log的罗盘并不是随着事务的提交才写入的，而是在事务的执行过程中，变开始写入redolog文件中
**设么时候释放** 当对应事务的脏页写入到磁盘之后，redo log的使命也就完成可，重做日志占用的控件就可以重用（被覆盖）
**对应的物理文件** 默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&ib_logfile2
redo log有一个缓存区innodb_log_buffer，默认大小是8m, innodb先将redo log写入innodb_log-buffer中，再通过以下三种方式将日志刷新到缓冲区
*每秒一次刷新
*每个事务提交时会将重做日志刷新到重做日志文件
*当重做日志缓存可用空间少于一半时，重做日志缓存被刷新到重做日志文件

2. 回滚日志 （Undo Log)
**作用** 保证数据的原子性，保证事务发生之前的数据的一个版本，可用于会馆， 同时可以提供多版本并发控制下的读（MVCC），也即非锁定读
**内容** 逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是物理页面上操作实现的，这一点不同于redo log
**什么时候产生** 事务开始之前，将当前版本事务生成undo log，undo也会产生redo来保证undo log的可靠性
**什么时候释放** 当事务提交之后，undo并不能立马被删除，而是放入待清理的链表，由purge线程怕段是否由其他事务在使用undo段中标的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间

undo是事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redo log的产生、
默认情况下，undo文件保持在共享空间的，也即ibdatafile文件中，当数据中发生一些大的事务性操作的时候，要生成大量的undox信息，全部保存在共享表空间中的
因此共享表空间可能会变得很大，默认情况下，也就是undo日志使用共享表空间的时候，被撑大的共享表空间是不会也不能自动收缩的
因此。mysql5.7之后 独立undo 表空间的配置就显得很有必要了

3. 二进制日志 （binlog)
**作用** 用于复制，在主从复制中，从库利用主库上的binlog进行重播， 实现主从同步
**内容** 逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句
但又完全是sql语句这么简单，而是包括了执行的sql语句的反向信息，也就意味着delete对应着delete本身和其反向的insert， update对应着update执行前后的版本信息，insert对应着delete和insert本身的信息
**什么时候产生** 事务提交的时候，一次性将事务中的sql语句按照一定的格式记录到binlog中
**什么时候释放**  binlog的默认保持时间是由参数expire_logs_days配置。

4. 错误日志 （error log)
错误日志记录这mysqld启动和停止，以及服务器在运行国新恒中发生的错误的相关信息

5. 查询日志（General Query Log)
记录了服务器接收到的每个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误，查询日志都会记录下下，记录的格式为{Time, Id, Command, Argument}.

6. 慢查询日志
慢查询日志记录执行时间过长和没有使用索引的查询语句，报错的select update delete 和 insert语句，慢查询日志只会记录执行成功的语句

### 4.4.22 脏读 可重复读 不可重复读 幻读的区别？
1.脏读
脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最总不会存到数据库中，也就是不存在的数据。

2.可重复读
可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据更新操作

3.不可重复读
对比可重复读，不可重复读指的是在同一事务中，不同的时刻读到的同一批数据可能不一样的，可能会受到其它事务的影响，比如其它事务改了这批数据并提交了，通常针对数据更新
（UPDATE）操作

4.幻读
幻读是针对插入操作来说的，假设事务A对某行的内容作了更高，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了。
而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉


### 4.4.23 事务的隔离级别？
1. 读未提交（Read Uncommitted)
查询不加锁，一个事务可以读取另一个未提交事务的数据。会产生脏读 不可重复读 以及 幻读、

2. 读已提交（Read Committed)
只能读到已经提交了的内容，通常是通过快照读完成。不会产生脏读，但是可能会有不可重复读及幻读

4. 可重复读（Repeated Read)
通过快照读读取，只读已提交的内容，但同时会加锁，不允许update操作。这样就避免了不可重复读

5. 串行化（Serialalizable）
事务串行化顺序执行，也就是一个一个排队执行。脏读 不可重复读 以及幻读都可以避免

### 4.4.24 binlog有哪些日志格式，区别是什么？
1. Statement
每一条会修改数据的sql都会记录在binlog中
优点是binlog文件较小，日志是包含用户执行的原始sql方便统计和审计，出现最早，兼容性也最好

2. Row
不记录sql语句上下文相关信息，仅保存哪条记录被修改
相比statement更加安全的复制格式，在否写情况下复制速度更快，系统的特殊函数也可以复制，更少的锁， 在复制时，对于更新和删除语句检查是和否有主见，如果有则直接执行，如果没有看是否有二级索引，没有全表扫描
缺点是binlog比较大，且无法从binlog看见用户执行sql

3. Mixed
Statement和Row的混合模式

### 4.4.25 Mysql Cpu占用飙升到100%应该如何处理？
1. show processlist，找出一定时间内状态无变化的进程kill掉
2. 查看超时日志和慢查询日志

### 4.4.26 InnoDB行锁如何实现？
InnoDB是基于索引来完成行锁
例: select * from tab_with_index where id = 1 for update;
for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,
如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起

### 4.4.27 死锁是如何产生的，如何解决？
当对哦个事务同时持有和请求同一资源上的锁而产生循环依赖的时候就产生了死锁。死锁发生在事务试图以不同的顺序锁定资源。
数据库实现了各种死锁探查和超时机制。例如Innodb这样复杂的存储引擎会提示循环依赖并且立即返回错误。Innodb在死锁超时后回滚最少排他行级锁的事务。
锁行为的顺序是存储引擎决定的。因此，一些存储引擎可能会在特定操作顺序下发生死锁，而一些不会发生死锁，其它的可能没有，死锁有两种
* 因为实际数据冲突而无法避免
* 因为存储引擎的工作方式而产生
只有部分或者完全回滚一个事务才可可能打破死锁。死锁是事务系统中客观存在的事实，设计上就应该考虑死锁。

如何处理死锁
死锁是事务型数据库典型的问题，但是除非它们频繁出现以至于你更本不能运行某个事务，它们一般是不危险的。正常地，你必须编写你的应用程序使得它们总是准备如果因为死锁而 回滚一个事务就重新发出一个事务。

InnoDB使用自动行级锁定。即使在只插入或删除单个行的事务的情况下，你可以遇到死锁。这是因为这些操作不是真正的“极小的”，它们自动对插入或删除的行的（可能是数个）索引记录设置锁定。

你可以用下列技术对付死锁减少它们发生的可能性：

用Use SHOW INNODB STATUS来确定最后一个死锁的原因。这样可以帮助你调节应用程序来避免死锁。

总是准备着重新发出事务，如果它因为死锁而失败了。死锁不危险，再试一次。

经常提交你的事务。小事务更少地倾向于冲突。

如果你正使用锁定读，（SELECT ... FOR UPDATE或 ... LOCK IN SHARE MODE），试着用更低的隔离级别，比如READ COMMITTED。

以固定的顺序访问你的表和行。则事务形成良好定义的查询并且没有死锁。

添加精心选定的索引到你的表。则你的查询需要扫描更少的索引记录并且因此设置更少的锁定。使用EXPLAIN SELECT来确定对于你的查询,MySQL认为哪个索引是最适当的。

使用更少的锁定。如果你可以接受允许一个SELECT从一个旧的快照返回数据，不要给它添加FOR UPDATE或LOCK IN SHARE MODE子句。这里使用READ COMMITTED隔离级别是比较好的，因为每个在同一事务里的持续读从它自己新鲜的快照里读取。

如果没有别的有帮助的了，用表级锁定系列化你的事务。用LOCK TABLES对事务型表（如InnoDB)的正确方法是设置AUTOCOMMIT = 0 并且不调用UNLOCK TABLES直到你明确地提交了事务。例如，如果你需要写表t1并从表t读，你可以按如下做：

SET AUTOCOMMIT=0;
 
LOCK TABLES t1 WRITE, t2 READ, ...;
 
[do something with tables t1 and t2 here];
 
COMMIT;
 
UNLOCK TABLES;
表级锁定使得你的事务很好地排队，并且死锁被避免了。

领一个系列化事务的方法是创建一个辅助的“semaphore” 表，它只包含一个单行。让每个事务在访问其它表之前更新那个行。以这种方式，所有事务以序列的方式发生。注意，InnoDB即时死锁检测算法也能在这种情况下起租用，因为系列化锁定是行级锁定。超时方法，用MySQL表级锁定，必须被用来解决死锁。

在应用程序中使用LOCK TABLES命令，如果AUTOCOMMIT=1,MySQL不设定InnoDB表锁定。